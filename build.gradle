import org.ajoberstar.grgit.*
import org.asciidoctor.groovydsl.AsciidoctorExtensions
import org.asciidoctor.Asciidoctor
import org.asciidoctor.OptionsBuilder
import org.asciidoctor.SafeMode

buildscript {
    ext {
        asciidoctorjVersion = '1.5.4.1'
        asciidoctorjPdfVersion = '1.5.0-alpha.11'
        asciidoctorGroovyDslVersion = '1.0.0.Alpha2'
        gradleGitVersion = '1.4.2'
    }

    repositories {
        jcenter()
    }

    dependencies {
        classpath "org.asciidoctor:asciidoctorj:$asciidoctorjVersion"
        classpath "org.asciidoctor:asciidoctorj-pdf:$asciidoctorjPdfVersion"
        classpath "org.asciidoctor:asciidoctorj-groovy-dsl:$asciidoctorGroovyDslVersion"
        classpath "org.ajoberstar:gradle-git:$gradleGitVersion"
        classpath 'net.sf.docbook:docbook-xsl:1.79.1:ns-resources@zip'
        classpath fileTree(dir: "${rootProject.projectDir}/lib", include: '*.jar')
        classpath files("docbook/catalog/")
    }
}

plugins {
    id 'base'
    id 'org.neo4j.doc.build.vale' version '1.0-alpha01'
    id 'org.neo4j.doc.build.saxon' version '1.0-alpha01'
    id 'org.neo4j.doc.build.docbook' version '1.0-alpha01'
    id "de.undercouch.download" version "3.2.0"
}

// apply plugin 'vale'

repositories {
       // maven { }
       mavenLocal()
}

version = '1.5'

def traceDocbook = hasProperty('traceDocbook') ? true : false

// def docsRepository = System.env.MAVEN_REPO_LOCAL

if (!project.hasProperty("neo4jVersion")) { ext.neo4jVersion = "3.4.0-SNAPSHOT" }
if (!project.hasProperty("driverVersion")) { ext.driverVersion = "1.5" }
if (!project.hasProperty("ogmVersion")) { ext.ogmVersion = "2.1.2" }
// if (null == docsRepository) { ext.docsRepository = "https://m2.neo4j.org/content/repositories/snapshots/" }

configurations {
    docs {
        description "docs configuration"
    }
}

ext {
    driverDocsBuildDir = "${rootProject.buildDir}/driver-documentation/${driverVersion}"
    driverDocsGitUri = "https://github.com/neo4j/driver-documentation.git"
    driverDocsGitRef = "1.5"
}
ext {
    // Set `neo4jDocVersion` for use in the generated docs
    // Those docs that follow Neo4j versions do so tracking `major.minor[-prerelease]`
    // So, drop the patch version:
    neo4jVersionParts = neo4jVersion.split('-')
    neo4jDocVersion = neo4jVersionParts[0][0..2]
    if (1 < neo4jVersionParts.size()) {
        neo4jDocVersion += "-preview"
    }

    // Make it a little easier to build release and pre-release OGM docs.
    ogmDocVersion = ogmVersion.tokenize('.')[0..1].join(".")
    if (ogmVersion.contains("-")) {ogmDocVersion += "-pre"}

    docId = 'driver-manual'
    olinkdb = "${buildDir}/olinkdb/olinkdb.xml"
}

ext {
    driverDocVersion = driverVersion
    copyrightYear = '2017'
    docsBaseUri = "https://neo4j.com/docs"
    docsCrossReferenceBaseUris = [
            'operations-manual-base-uri' : "${docsBaseUri}/operations-manual/${neo4jDocVersion}",
            'cypher-manual-base-uri'     : "${docsBaseUri}/cypher-manual/${neo4jDocVersion}",
            'driver-manual-base-uri'     : "${docsBaseUri}/driver-manual/${driverDocVersion}",
            'java-reference-base-uri'    : "${docsBaseUri}/java-reference/${neo4jDocVersion}",
            'rest-docs-base-uri'         : "${docsBaseUri}/rest-docs/${neo4jDocVersion}",
            'ogm-manual-base-uri'        : "${docsBaseUri}/ogm-manual/${ogmDocVersion}"
    ]
    commonAsciidoctorAttributes = [
            'copyright-year'                   : copyrightYear,
            'copyright'                        : "${copyrightYear} Neo Technology",
            'common-license-page-uri'          : "${docsBaseUri}/license",
            'neo4j-version'                    : neo4jDocVersion,
            'neo4j-version-exact'              : neo4jVersion,
            'neo4j-git-version'                : neo4jDocVersion,
            'driver-version'                   : driverVersion,
            'doctype'                          : 'book',
            'icons'                            : 'font',
            'imagesdir'                        : './images',
            'attribute-missing'                : 'warn',
    ] + docsCrossReferenceBaseUris
    htmlAsciidoctorAttributes = [
            'toc'        : 'left',
            'stylesdir'  : 'css',
            'stylesheet' : 'style.css',
            'sectanchors': '',
            'docinfo1'   : '',
            'linkcss'    : ''
    ]
    docbookAsciidoctorAttributes = [:]
    pdfAsciidoctorAttributes = [
            'source-highlighter': 'rouge',
            'pdf-style'         : 'neo',
            'pdf-fontsdir'      : "$rootProject.buildDir/fonts".toString(),
            'doctype'           : 'book',
            'toc'               : '',
            'showlinks'         : '',
            'nonhtmloutput'     : '',
    ]
    fonts = [
            'Open Sans.zip'  : 'https://www.google.com/fonts/download?kit=3hvsV99qyKCBS55e5pvb3ltkqrIMaAZWyLYEoB48lSQ',
            'Inconsolata.zip': 'https://www.google.com/fonts/download?kit=CNj0Ze1H6w4FVgc32wmZS4fD-WQWLbF4rYwcBGowFYY',
            'Lora.zip'       : 'https://www.google.com/fonts/download?kit=iwrHM7FQEcKgsUvDuXxrPg',
    ]
}

ext {
    driverLanguages = [
            'dotnet': [
                    'name'   : 'C#',
                    'version': '1.5.2',
                    'gitref' : '1.5.2',
                    'url'    : 'https://www.nuget.org/packages/Neo4j.Driver'
            ],
            'java': [
                    'name'   : 'Java',
                    'version': '1.5.0',
                    'gitref' : '1.5.0',
                    'url'    : 'http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22org.neo4j.driver%22%20AND%20a%3A%22neo4j-java-driver%22'
            ],
            'javascript': [
                    'name'   : 'JavaScript',
                    'version': '1.5.1',
                    'gitref' : '1.5.1',
                    'url'    : 'https://www.npmjs.com/package/neo4j-driver'
            ],
            'python'    : [
                    'name'   : 'Python',
                    'version': '1.5.3',
                    'gitref' : '1.5.3',
                    'url'    : 'https://pypi.python.org/pypi/neo4j-driver'
            ]
    ]
    resourcesDir = "${projectDir}/src/main/resources"
    adoc = null

    // a wrapper closure around executing a string
    // can take either a string or a list of strings (for arguments with spaces)
    runCommand = { strList ->
        assert ( strList instanceof String ||
            ( strList instanceof List && strList.each{ it instanceof String } ) \
    )
        def proc = strList.execute()
        // proc.in.eachLine { line -> println line }
        proc.out.close()
        proc.waitFor()
        // print "[INFO] ( "
        // if(strList instanceof List) {
        //     strList.each { print "${it} " }
        // } else {
        //     print strList
        // }
        // println " )"
        if (proc.exitValue()) {
            println "gave the following error: "
            println "[ERROR] ${proc.getErrorStream()}"
        }
        assert !proc.exitValue()
    }

}

project.ext.driverLanguages.each { lang, info ->
    project.ext.commonAsciidoctorAttributes["$lang-driver-version"] = info['version']
    project.ext.commonAsciidoctorAttributes["$lang-root"] = targetGitdir(lang, info['gitref'])
    project.ext.htmlAsciidoctorAttributes["include-with-$lang"] = ''
    project.ext.docbookAsciidoctorAttributes["include-with-$lang"] = ''

    task ("${lang}DriverApiDocs", type: Tar) {
        description "Package API docs for the ${lang} driver."
        println "Packaging API docs for the ${lang} driver from a manually build, local, static copy."
        println "This should be fixed to use proper dependencies ASAP."
        baseName "${lang}-driver"
        version driverVersion
        extension "tar.gz"
        compression Compression.GZIP
        from {
            file("${projectDir}/shared/${lang}-driver-api-docs").exists() ? "${projectDir}/shared/${lang}-driver-api-docs" : "apidocs/${lang}"
        }
        into {
            "api/${baseName}/${driverVersion}"
        }
        destinationDir file("${buildDir}/distributions")
    }
    task ("${lang}DriverSources") {
        description "Clones the ${lang} driver sources from GitHub or uses local checkouts."
        def targetDir = targetGitdir(lang, info['gitref'])
        outputs.dir targetDir
        onlyIf { !file(targetDir).exists() }
        doLast {
            println "Cloning neo4j-$lang-driver repository."
            Grgit.clone(dir: targetDir,
                        uri: "https://github.com/neo4j/neo4j-$lang-driver.git",
                        refToCheckout: info['gitref'])

        }
    }
}

def driverSourcesTasks = driverLanguages.collect {"${it.getKey()}DriverSources"}
task prepareDriverSources(dependsOn: driverSourcesTasks){
    description "Prepare driver sources."
}

// task prepareDriverDocs {
//     description 'Clones the driver documentation from GitHub.'
//     outputs.dir file(driverDocsBuildDir)
//     onlyIf { !file(driverDocsBuildDir).exists() }
//     doLast {
//         println "Cloning driver-documentation repository."
//         Grgit.clone(dir: file(driverDocsBuildDir), uri: driverDocsGitUri, refToCheckout: driverDocsGitRef)
//     }
// }

task toDocbook(dependsOn: prepareDriverSources) {
    description 'Build Neo4j Object-Graph Mapping (OGM) Manual Docbook output.'
    ext.sourceDir = "${projectDir}/src/main/asciidoc"
    def sourceFile = new File("${sourceDir}/index.adoc")
    def imagesDir = '../images'
    def docbookOutputDir = "${buildDir}/docbook/${driverDocVersion}"
    def driverDocsSourceDir = "${driverDocsBuildDir}/src/main/asciidoc"
    def templateDir = "${resourcesDir}/templates/docbook"
    inputs.dir sourceDir
    outputs.dir docbookOutputDir
    doLast {
        def attrs = project.ext.commonAsciidoctorAttributes + project.ext.docbookAsciidoctorAttributes +
                [
                    // 'importdir'              : importDir,
                    'driver-docs-source-dir' : driverDocsSourceDir,
                    'driver-manual-version'  : driverDocVersion,
                    'driver-manual-title'    : "Drivers",
                    'project-root'           : "${rootProject.projectDir}",
                    // 'initial-leveloffset'    : '0',
                    'docinfo1'               : '',
                    'csv-dir'                : "${docsCrossReferenceBaseUris['cypher-manual-base-uri']}/csv",
                    'version'                : driverDocVersion,
                ]
        // def attrs = project.ext.commonAsciidoctorAttributes + [
        //     'version'             : driverDocVersion,
        //     'docinfo1'            : '',
        // ]
        attrs['imagesdir'] = imagesDir
        attrs['stylesheet'] = 'github.css'
        attrs['stylesdir'] = '../css'
        attrs['linkcss'] = ''
        def opts = OptionsBuilder.options()
                .backend('docbook5')
                .safe(SafeMode.UNSAFE)
                .toDir(new File(docbookOutputDir))
                .templateDir(new File(templateDir))
                .mkDirs(true)
                .attributes(attrs)
        def asciidoctor = getAsciidoctor(sourceDir, imagesDir, false, true)
        asciidoctor.convertFile(sourceFile, opts.get())
    }
    finalizedBy {toDocbookCopyResources}
    finalizedBy {preprocess}
}

task toDocbookCopyResources(type: Copy) {
    from(projectDir) {
        include 'images/**'
    }
    from (toDocbook.sourceDir) {
        include "images/**"
    }
    into "${buildDir}/docbook/${driverDocVersion}"
}

preprocess {
    description 'Fix things in the DocBook XML before further processing.'
    dependsOn toDocbook
    def sourceFile = "${buildDir}/docbook/${driverDocVersion}/index.xml"
    def toolsDir = "${rootProject.projectDir}/docbook"

    doFirst {
        def cmd = ["${projectDir}/bin/post-process.sh", sourceFile, "${projectDir}/bin/post-process.sed"]
        runCommand(cmd)
    }

    input sourceFile
    outFile sourceFile

    parameters([
        "book-id": "$docId"
    ])
}

html {
    description 'Build Neo4j Object-Graph Mapping (OGM) Manual to multi-page HTML.'
    dependsOn toDocbook
    doFirst { println "[+] Building Neo4j Object-Graph Mapping (OGM) Manual multi-page HTML" }
    def docbookInputDir = "${buildDir}/docbook/${driverDocVersion}"
    def sourceFile = "${docbookInputDir}/index.xml"
    def docbookSourceDir = "${projectDir}/src/main/docbook"
    def contentMap = "${docbookSourceDir}/content-map.xml"
    def outputDir = "${buildDir}/html/${driverDocVersion}"
    def toolsDir = "${rootProject.projectDir}/docbook"
    def css = [
        '//maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css',
        '//cdnjs.cloudflare.com/ajax/libs/font-awesome/4.1.0/css/font-awesome.min.css',
        '//fonts.googleapis.com/css?family=Open+Sans:400,300,400italic,600,300italic',
        '//cdnjs.cloudflare.com/ajax/libs/codemirror/5.11.0/codemirror.min.css',
        '//cdnjs.cloudflare.com/ajax/libs/codemirror/5.11.0/theme/neo.min.css',
        'css/extra.css',
        'css/chunked-base.css'
    ].join(" ")
    def scripts = [
        '//ajax.googleapis.com/ajax/libs/jquery/2.2.0/jquery.min.js',
        '//maxcdn.bootstrapcdn.com/bootstrap/3.3.6/js/bootstrap.min.js',
        '//cdnjs.cloudflare.com/ajax/libs/codemirror/5.11.0/codemirror.min.js',
        '//cdnjs.cloudflare.com/ajax/libs/codemirror/5.11.0/addon/runmode/runmode.min.js',
        '//cdnjs.cloudflare.com/ajax/libs/codemirror/5.11.0/mode/javascript/javascript.min.js',
        '//cdnjs.cloudflare.com/ajax/libs/codemirror/5.11.0/mode/shell/shell.min.js',
        '//cdnjs.cloudflare.com/ajax/libs/codemirror/5.11.0/mode/python/python.min.js',
        '//cdnjs.cloudflare.com/ajax/libs/codemirror/5.11.0/mode/xml/xml.min.js',
        '//cdnjs.cloudflare.com/ajax/libs/codemirror/5.11.0/mode/clike/clike.min.js',
        '//cdnjs.cloudflare.com/ajax/libs/codemirror/5.11.0/mode/cypher/cypher.min.js',
        '//cdnjs.cloudflare.com/ajax/libs/codemirror/5.11.0/mode/properties/properties.min.js',
        '//cdnjs.cloudflare.com/ajax/libs/codemirror/5.11.0/mode/groovy/groovy.min.js',
        'javascript/colorize.js',
        'javascript/tabs-for-chunked.js',
        'javascript/mp-nav.js',
        'javascript/versionswitcher.js',
        'javascript/version.js',
    ].join(" ")

    // Task configuration
    inputs.dir docbookInputDir
    outputs.dir outputDir
    input sourceFile

    // Stylesheet parameters
    parameters ([
            "base.dir": "${outputDir}",
            "chunk.section.depth": "0",
            "html.ext": ".html",
            "make.clean.html": "1",
            "chunker.output.method": "html",
            "chunker.output.encoding": "UTF-8",
            "chunker.output.indent": "yes",
            "use.id.as.dirname": "1",
            "html.stylesheet": "${css}",
            "html.script": "${scripts}",
            "neo.search": "1",
            "generate.toc": "''",
            "chunk.toc": "${contentMap}",
            "header.rule": "0",
            "neo.documentation.library.links":
            """
            Operations_Manual=${docsCrossReferenceBaseUris['operations-manual-base-uri']}/
            Cypher_Manual=${docsCrossReferenceBaseUris['cypher-manual-base-uri']}/
            Driver_Manual=${docsCrossReferenceBaseUris['driver-manual-base-uri']}/
            OGM_Manual=${docsCrossReferenceBaseUris['ogm-manual-base-uri']}/
            Java_Reference=${docsCrossReferenceBaseUris['java-reference-base-uri']}/
            REST_Docs=${docsCrossReferenceBaseUris['rest-docs-base-uri']}/
            """,
            "target.database.document": "file://${olinkdb}",
            "current.docid": "$docId"
    ])
    finalizedBy { copyHtmlResources }
}

task copyHtmlResources(type: Copy) {
    description 'Copy resources for the multi-page Neo4j Object-Graph Mapping (OGM) Manual'
    inputs.dir "${projectDir}/resources/css"
    inputs.dir "${projectDir}/resources/javascript"
    inputs.dir "${projectDir}/resources/images"
    inputs.dir "${resourcesDir}/css"
    inputs.dir "${resourcesDir}/javascript"
    from ("${toDocbook.sourceDir}") {
        include 'images/**'
    }
    from ("${resourcesDir}") {
        include 'images/**'
        include 'javascript/**'
        include 'css/**'
    }
    from ("${projectDir}/resources") {
        include 'images/**'
        include 'css/extra.css'
        include 'css/chunked-base.css'
        include 'javascript/colorize.js'
        include 'javascript/tabs-for-chunked.js'
        include 'javascript/mp-nav.js'
        include 'javascript/versionswitcher.js'
        include 'javascript/version.js'
    }
    into "${buildDir}/html/${driverDocVersion}"
}

task packageHtml(type: Tar, dependsOn: html) {
    baseName "driver-manual"
    version driverDocVersion
    extension 'tar.gz'
    compression Compression.GZIP
    from {
        "${buildDir}/html/${driverDocVersion}"
    }
    into {
        "${baseName}/${driverDocVersion}"
    }
    destinationDir file("$rootProject.buildDir/distributions")
}

def targetGitdir(lang, gitref) {
    if (project.hasProperty('localDriverSources')) {
        file("$projectDir/../neo4j-$lang-driver")
    } else {
        file("${rootProject.buildDir}/driver-sources/${lang}-driver/${gitref}")
    }
}

def deps = driverLanguages.collect {"${it.getKey()}DriverApiDocs"}
task driverApiDocsPackage(dependsOn: deps) {
    description 'Package the driver API docs.'
}

def getAsciidoctor(sourceDir, imagesDir, doConsole, filterTabbedExamples) {

    AsciidoctorExtensions.extensions {

        if (sourceDir && imagesDir) {
            block(name: 'dot', contexts: [':listing']) {
                parent, reader, attributes ->
                    def indata = reader.readLines().join("\n");
                    def svgfile = attributes[2]
                    def svgfilepath = "${sourceDir}/${imagesDir}/${svgfile}"
                    def cmd = ["$projectDir/src/main/extensions/filters/dot/dot.sh", indata, "dummy", svgfilepath]
                    if (attributes[3] != null) {
                        cmd.add(attributes[3])
                    }
                    if (attributes[4] != null) {
                        cmd.add(attributes[4])
                    }
                    runCommand(cmd)
                    attributes['target'] = svgfile
                    attributes['alt'] = 'alt'
                    createBlock(parent, 'image', [], attributes, [:])
            }
        }

        block(name: 'queryresult', contexts: [':listing']) {
            parent, reader, attributes ->
                createBlock(parent, 'listing', reader.readLines(), attributes + ['role': 'queryresult'], [:])
        }

        block(name: 'console', contexts: [':listing']) {
            parent, reader, attributes ->
                if (doConsole) {
                    def content = reader.readLines()
                    def db = []
                    def query = []
                    def foundEmptyLine = false
                    content.each {
                        if (foundEmptyLine) {
                            query.add(it)
                        } else {
                            if (it.trim()) {
                                db.add(it)
                            } else {
                                foundEmptyLine = true
                            }
                        }
                    }
                    if (!db) {
                        db.add("none")
                    }
                    if (!query) {
                        throw new IllegalArgumentException("A query has to be defined.")
                    }
                    def body = []
                    body.add('<p class="cypherconsole">')
                    body.add('<span class="database">')
                    body.add(db)
                    body.add('</span><span class="command"><strong>')
                    body.add(query.join(' '))
                    body.add('</strong></span></p>')
                    createBlock(parent, 'pass', body, attributes, [:])
                } else {
                    null
                }
        }

        block(name: 'snippet', contexts: [':listing']) {
            parent, reader, attributes ->
                def lang = attributes[2]
                def lines = reader.readLines()
                def config = [
                    'classifier': 'test-sources',
                ]
                lines.each {
                    def l = it.trim()
                    if (!l.isEmpty()) {
                        def (key, value) = it.split('=', 2)
                        config[key] = value
                    }
                }
                if (!config.containsKey("tag")) {throw new IllegalArgumentException("'tag' must be specified")}
                if (!config.containsKey("source")) {throw new IllegalArgumentException("'source' must be specified")}
                if (!config.containsKey("component")) {throw new IllegalArgumentException("'component' must be specified")}
                if (!config.containsKey("classifier")) {throw new IllegalArgumentException("'classifier' must be specified")}
                def tablength = "    "
                if (config.containsKey("tablength")) {
                    tablength = " " * config["tablength"].toInteger()
                }
                def START = "START SNIPPET: ${config['tag']}"
                def END = "END SNIPPET: ${config['tag']}"
                def path = "${neo4jManualContentsDir}/${config['classifier']}/${config['component']}-${config['classifier']}-jar/${config['source']}"
                def emit = false
                def mindent = Integer.MAX_VALUE
                def buf = []
                def f = new File(path)
                if (f.exists()) {
                    f.eachLine { line ->
                        if (-1 < line.indexOf(END)) {
                            emit = false
                        }
                        if (emit) {
                            def meat = line.replaceAll(/^\s+/, '')
                            if (!meat.isEmpty()) {
                                def indent = line.substring(0, (line.length() - meat.length())).replaceAll(/\t/, tablength)
                                mindent = Math.min(mindent, indent.length())
                                buf.add(indent + meat)
                            } else {
                                buf.add('')
                            }
                        }
                        if (-1 < line.indexOf(START)) {
                            emit = true
                        }
                    }
                }
                def snippet = []
                if (buf.isEmpty()) {
                    println('  [xxx] Missing snippet for tag "' + config['tag']
                        + '" in file "' + config['source']
                        + '" in component "' + config['component']
                        +'" with classifier "' + config['classifier'] + '".'
                        + "\n" + "Path=" + path
                        )
                    throw new IllegalArgumentException('Missing snippet for tag "' + config['tag']
                        + '" in file "' + config['source'] 
                        + '" in component "' + config['component'] 
                        +'" with classifier "' + config['classifier'] + '".'
                    )

                } else {
                    buf.each {
                        if (it.length() < mindent) {
                            snippet.add(it)
                        } else {
                            snippet.add(it.substring(mindent))
                        }
                    }
                }
                def newAttributes = ['style': 'source', 'language': lang]
                if (attributes.containsKey('title')) {
                    newAttributes['title'] = attributes['title']
                }
                createBlock(parent, 'listing', snippet, newAttributes, [:])
        }

    }
    project.ext.adoc = Asciidoctor.Factory.create()
    if (filterTabbedExamples) {
        adoc.rubyExtensionRegistry()
            .loadClass(new FileInputStream(file("${rootProject.projectDir}/src/main/extensions/tabbed_example_processor.rb")))
            .treeprocessor("TabbedExampleProcessor")
    }

    project.ext.adoc
}

// asciidoctorPdf.onlyIf { !project.hasProperty('noPdf') }

// task('dist', dependsOn: ['asciidoctorHtml', 'asciidoctorPdf']) {
//     description 'Build HTML and PDF outputs.'
// }

// vim: set fdm=expr:
